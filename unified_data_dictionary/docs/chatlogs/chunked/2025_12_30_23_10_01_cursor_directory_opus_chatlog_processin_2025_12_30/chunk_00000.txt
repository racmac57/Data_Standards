# Directory Opus chatlog processing command
_Exported on 12/30/2025 at 23:09:17 EST from Cursor (2.3.15)_

---

**User**

@unified_data_dictionary/scripts/Process_UDD_Chatlog.bat @nodeselect
"C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\Standards\unified_data_dictionary\scripts\Process_UDD_Chatlog.bat" {filepath$}
please explain how this works. I have the attached image showing the DOpus button set up

---

**Cursor**


## Directory Opus Command Breakdown

The Directory Opus command has two parts:

1. `@nodeselect` — Directory Opus directive that prevents changing the file selection after the command runs. 2. `"C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\Standards\unified_data_dictionary\scripts\Process_UDD_Chatlog.bat" {filepath$}` — Executes the batch file and passes the selected file path. `{filepath$}` is a Directory Opus variable that expands to the full path of the selected file(s). If multiple files are selected, it passes each one. ## How the Batch File Works

The batch file (`Process_UDD_Chatlog.bat`) processes a chatlog file in 5 steps:

### Step 0: Watcher Check
- Checks if the Python watcher (`watcher_splitter.py`) is running. ### Step 1: Move to Raw Folder
- Moves the selected file to `docs\chatlogs\raw\` for archival. ### Step 2: Send to Chunker
- Copies the file to the chunker watch folder (`C:\_chunker\02_data`) using an atomic copy (`.part` then rename) so the watcher sees a single event. ### Step 3: Monitor for Output
- Waits up to 180 seconds (scans every 5 seconds) for the chunker to create a directory with chunk files in the output folder. ### Step 4: Verify Chunks
- Counts the `chunk_*.txt` files created. ### Step 5: Copy Output to Project
- Copies the chunked directory back to `docs\chatlogs\chunked\` in the project. ## Complete Workflow

1. You select a chatlog file in Directory Opus. 2. You click the "Process_UDD_Chatlog" button (or use its hotkey if assigned). 3. Directory Opus passes the file path to the batch script. 4. The batch script:
   - Archives the original to `raw/`
   - Queues it for chunking
   - Waits for processing
   - Retrieves the chunked results to `chunked/`

This automates the chatlog processing pipeline from file selection to chunked output. ---

**User**

how do I make the process usable for other directories? I assume the button will only work for unified_data_dictionary

---

**Cursor**


Making the script work for other directories. Reviewing the current structure, then updating it to be more flexible. Making the script work for any directory. Creating a generic version that auto-detects the project root or accepts it as a parameter:



Creating a generic version that works with any project directory. Two options:


```bat
@echo off
REM ============================================================================
REM Generic Chatlog Processor
REM ============================================================================
REM Version: 2.0.0 (Generic - works with any project directory)
REM ============================================================================
REM Usage:
REM   Process_Chatlog.bat <filepath> [project_root]
REM
REM   If project_root is not provided, auto-detects by looking for docs\chatlogs
REM   folder structure in the file's directory tree. REM ============================================================================

setlocal enabledelayedexpansion

REM External paths (shared across all projects)
set "CHUNKER_ROOT=C:\_chunker"
set "CHUNKER_INPUT=C:\_chunker\02_data"
set "CHUNKER_OUTPUT=%OneDriveCommercial%\KB_Shared\04_output"

REM ============================================================================
REM CHECK: File Selection
REM ============================================================================
if "%~1"=="" (
    echo [ERROR] No file selected. pause
    exit /b 1
)

set "INPUT_FILE=%~1"
set "FILENAME=%~nx1"
set "BASENAME=%~n1"
set "FILE_DIR=%~dp1"

REM ============================================================================
REM DETECT: Project Root
REM ============================================================================
set "PROJECT_ROOT=%~2"

if "!PROJECT_ROOT! "=="" (
    echo [INFO] Auto-detecting project root...
    REM Walk up directory tree looking for docs\chatlogs folder
    set "CURRENT_DIR=!FILE_DIR!" :FIND_PROJECT_ROOT
    REM Remove trailing backslash
    if "!CURRENT_DIR:~-1! "=="\" set "CURRENT_DIR=!CURRENT_DIR:~0,-1!" REM Check if docs\chatlogs exists here
    if exist "!CURRENT_DIR!\docs\chatlogs\" (
        set "PROJECT_ROOT=!CURRENT_DIR!" goto PROJECT_FOUND
    )
    
    REM Move up one level
    for %%P in ("!CURRENT_DIR!") do set "PARENT_DIR=%%~dpP"
    if "!PARENT_DIR! "=="" (
        REM Reached root, try one more check at Standards level
        if exist "C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\Standards\docs\chatlogs\" (
            set "PROJECT_ROOT=C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\Standards"
            goto PROJECT_FOUND
        )
        goto PROJECT_NOT_FOUND
    )
    
    REM Remove trailing backslash from parent
    if "!PARENT_DIR:~-1! "=="\" set "PARENT_DIR=!PARENT_DIR:~0,-1!" set "CURRENT_DIR=!PARENT_DIR!" goto FIND_PROJECT_ROOT
    
    :PROJECT_NOT_FOUND
    echo [ERROR] Could not auto-detect project root. echo. echo Please provide project root as second parameter:
    echo   Process_Chatlog.bat "%INPUT_FILE%" "C:\path\to\project"
    echo. echo Or ensure the file is within a project that has: docs\chatlogs\ folder
    pause
    exit /b 1
    
    :PROJECT_FOUND
    echo   [OK] Detected project: !PROJECT_ROOT!
) else (
    echo   [OK] Using provided project root: !PROJECT_ROOT!
) REM Set project-specific paths
set "RAW_DIR=!PROJECT_ROOT!\docs\chatlogs\raw"
set "CHUNKED_DIR=!PROJECT_ROOT!\docs\chatlogs\chunked"

REM Extract project name for display
for %%P in ("!PROJECT_ROOT!") do set "PROJECT_NAME=%%~nxP"

echo. echo ============================================================================
echo  CHATLOG PROCESSOR v2.0.0 - !PROJECT_NAME! echo ============================================================================
echo. echo Processing: %FILENAME%
echo Project:    !PROJECT_ROOT! echo. REM Check if watcher is running
echo [STEP 0/5] Checking watcher status...
powershell -NoProfile -Command "$watcher = Get-Process python -ErrorAction SilentlyContinue | Where-Object { try { $cmdLine = (Get-WmiObject Win32_Process -Filter \"ProcessId = $($_.Id)\" -ErrorAction SilentlyContinue).CommandLine; $cmdLine -like '*watcher_splitter.py*' } catch { $false } }; if ($watcher) { exit 0 } else { exit 1 }" >nul 2>&1
if errorlevel 1 (
    echo   [WARNING] Watcher may not be running! echo   Please ensure watcher is running: python watcher_splitter.py
    echo   Continuing anyway...
    echo.
) else (
    echo   [OK] Watcher is running
    echo.
) REM ============================================================================
REM STEP 1: Move to Project Raw Folder
REM ============================================================================
echo [STEP 1/5] Saving to project raw folder...

if not exist "!RAW_DIR!" mkdir "!RAW_DIR!" if /i "%~dp1"=="!RAW_DIR!\" (
    echo   [INFO] File is already in raw folder.
) else (
    move /Y "%INPUT_FILE%" "!RAW_DIR!\" >nul
    if errorlevel 1 (
        echo ERROR: Failed to move to raw folder. pause
        exit /b 1
    )
    echo   [OK] Saved to: docs\chatlogs\raw\%FILENAME%
)

REM ============================================================================
REM STEP 2: Send Atomic Copy to Chunker
REM ============================================================================
echo. echo [STEP 2/5] Sending atomic copy to chunker...

if not exist "%CHUNKER_INPUT%" (
    echo   [ERROR] Watch folder does not exist: %CHUNKER_INPUT%
    pause
    exit /b 1
)

REM 1. Copy as .part (Watcher ignores this)
copy /Y "!RAW_DIR!\%FILENAME%" "%CHUNKER_INPUT%\%FILENAME%.part" >nul 2>&1
if errorlevel 1 (
    echo   [ERROR] Failed to copy file to watch folder
    pause
    exit /b 1
)

REM 2. Rename to final (Watcher sees ONE event)
ren "%CHUNKER_INPUT%\%FILENAME%.part" "%FILENAME%" >nul 2>&1
if errorlevel 1 (
    echo   [ERROR] Failed to rename file in watch folder
    pause
    exit /b 1
)

echo   [OK] File queued for processing

REM ============================================================================
REM STEP 3: Monitor for Output
REM ============================================================================
echo. echo [STEP 3/5] Waiting for processed files...
echo   Target: %BASENAME%...
echo   Timeout: 180 seconds (scanning every 5 seconds)
echo. REM Expand environment variables in output path
for /f "delims=" %%A in ('powershell -Command "[System.Environment]::ExpandEnvironmentVariables('%CHUNKER_OUTPUT%')"') do set "EXPANDED_OUTPUT=%%A"

set "TIMEOUT_COUNT=0"
set "FOUND_PATH="
set "SCAN_INTERVAL=5"
set "MAX_SCANS=36"

:WAIT_FOR_CHUNK
timeout /t %SCAN_INTERVAL% /nobreak >nul
set /a TIMEOUT_COUNT+=1
set /a ELAPSED=TIMEOUT_COUNT * %SCAN_INTERVAL%

REM Show progress every 10 seconds
set /a MOD_CHECK=%TIMEOUT_COUNT% %% 2
if %MOD_CHECK%==0 echo   ...scanning (%ELAPSED%s)

REM Look for a DIRECTORY containing the basename
for /d %%D in ("%EXPANDED_OUTPUT%\*%BASENAME%*") do (
    REM Check if chunks exist in the directory
    dir /b "%%D\chunk_*.txt" >nul 2>&1
    if not errorlevel 1 (
        set "FOUND_PATH=%%D"
        goto FILES_FOUND
    )
)

REM Wait max 180 seconds (36 scans * 5 seconds)
if %TIMEOUT_COUNT% lss %MAX_SCANS% goto WAIT_FOR_CHUNK

echo. echo [ERROR] Chunking Timed Out
echo The watcher may be busy or the file is very large. echo. echo Diagnostics:
echo   - Timeout: 180 seconds
echo   - Watch folder: %CHUNKER_INPUT%
echo   - Output folder: %EXPANDED_OUTPUT%
echo   - Target file: %BASENAME%
echo. echo Troubleshooting:
echo   1. Check if watcher is running: python watcher_splitter.py
echo   2. Check watch folder for queued files: %CHUNKER_INPUT%
echo   3. Check if file was copied: dir "%CHUNKER_INPUT%\%FILENAME%"
echo   4. Check output folder: %EXPANDED_OUTPUT%
echo   5. Run diagnostic: powershell -File "%CHUNKER_ROOT%\scripts\Check-Watcher-Status.ps1" -FileName "%BASENAME%"
echo   6. For large files, increase MAX_SCANS in this script (currently %MAX_SCANS%)
echo. pause
exit /b 1

:FILES_FOUND
echo   [OK] Found output: %FOUND_PATH%

REM ============================================================================
REM STEP 4: Verify Chunks
REM ============================================================================
echo. echo [STEP 4/5] Verifying chunks...
set "CHUNK_COUNT=0"
for /f %%C in ('dir /b "%FOUND_PATH%\chunk_*.txt" 2^>nul ^| find /c /v ""') do set "CHUNK_COUNT=%%C"
if %CHUNK_COUNT% gtr 0 (
    echo   [OK] Found %CHUNK_COUNT% chunk files
) else (
    echo   [WARNING] No chunk files found, but directory exists
)
echo. REM ============================================================================
REM STEP 5: Copy Output to Project
REM ============================================================================
echo [STEP 5/5] Retrieving chunked files...

if not exist "!CHUNKED_DIR!" mkdir "!CHUNKED_DIR!" timeout /t 1 /nobreak >nul

REM Copy the results back to the project
xcopy "%FOUND_PATH%" "!CHUNKED_DIR!\" /E /I /Y >nul

if errorlevel 0 (
    echo   [OK] Copied data to: docs\chatlogs\chunked\
) else (
    echo [WARNING] Copy might have failed.
) echo. echo ============================================================================
echo  PROCESSING COMPLETE
echo ============================================================================
echo. echo Project:    !PROJECT_NAME! echo Raw Source:  docs\chatlogs\raw\%FILENAME%
echo Processed:   docs\chatlogs\chunked\%BASENAME%...
echo Chunks:      %CHUNK_COUNT% files
echo Processing time: ~%ELAPSED% seconds
echo. echo ============================================================================

timeout /t 4 /nobreak >nul
exit /b 0

```


Created a generic version. Here's what changed and how to use it:

## Changes

1. Auto-detection: walks up the directory tree from the selected file to find a `docs\chatlogs` folder
2. Optional project root parameter: you can pass it explicitly if needed
3. Generic title: shows the detected project name instead of hardcoding "UNIFIED DATA DICTIONARY"

## How to Use

### Option 1: Update Directory Opus to use the generic script

Change your Directory Opus command from:
```
@nodeselect
"C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\Standards\unified_data_dictionary\scripts\Process_UDD_Chatlog.bat" {filepath$}
```

To:
```
@nodeselect
"C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\Standards\unified_data_dictionary\scripts\Process_Chatlog.bat" {filepath$}
```

The script will auto-detect the project root for any file within a project that has a `docs\chatlogs` folder structure. ### Option 2: Create project-specific buttons

You can create multiple Directory Opus buttons for different projects, all pointing to the same generic script:

- Button: "Process UDD Chatlog" → `Process_Chatlog.bat {filepath$}`
- Button: "Process CAD Chatlog" → `Process_Chatlog.bat {filepath$}`
- Button: "Process RMS Chatlog" → `Process_Chatlog.bat {filepath$}`

All will work automatically because the script detects the project. ### Option 3: Manual project root specification

If you need to override auto-detection, you can pass the project root as a second parameter:
```
Process_Chatlog.bat {filepath$} "C:\path\to\specific\project"
```

## Project Structure Requirement

For auto-detection to work, your projects need this structure:
```
your_project/
  docs/
    chatlogs/
      raw/      (will be created if missing)
      chunked/  (will be created if missing)
```

The script walks up from the selected file until it finds a directory containing `docs\chatlogs`. Should I update the original `Process_UDD_Chatlog.bat` to call the generic script, or keep both versions? ```plaintext
@nodeselect
"C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\Standards\unified_data_dictionary\scripts\Process_UDD_Chatlog.bat" {filepath$}
```

```plaintext
@nodeselect
"C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\Standards\unified_data_dictionary\scripts\Process_Chatlog.bat" {filepath$}
```

```plaintext
Process_Chatlog.bat {filepath$} "C:\path\to\specific\project"
```

```plaintext
your_project/
  docs/
    chatlogs/
      raw/      (will be created if missing)
      chunked/  (will be created if missing)
```

---

**User**

see C:\_chunker\watcher_splitter.py the @c:\_chunker\watcher_splitter.py also adds a sidecar JSONwould this be helful with determining what the director is? ---

**Cursor**


Checking what metadata the sidecar JSON contains and how we can use it to determine the project directory. Checking the sidecar structure to see what metadata it contains:



The sidecar JSON includes the original `source_path`, which we can use to infer the project directory. Updating the batch script to check existing sidecar files for hints:



Enhancing the script to check existing sidecar JSON files for project hints:


```bat
@echo off
REM ============================================================================
REM Generic Chatlog Processor
REM ============================================================================
REM Version: 2.0.0 (Generic - works with any project directory)
REM ============================================================================
REM Usage:
REM   Process_Chatlog.bat <filepath> [project_root]
REM
REM   If project_root is not provided, auto-detects by looking for docs\chatlogs
REM   folder structure in the file's directory tree. REM ============================================================================

setlocal enabledelayedexpansion

REM External paths (shared across all projects)
set "CHUNKER_ROOT=C:\_chunker"
set "CHUNKER_INPUT=C:\_chunker\02_data"
set "CHUNKER_OUTPUT=%OneDriveCommercial%\KB_Shared\04_output"

REM ============================================================================
REM CHECK: File Selection
REM ============================================================================
if "%~1"=="" (
    echo [ERROR] No file selected. pause
    exit /b 1
)

set "INPUT_FILE=%~1"
set "FILENAME=%~nx1"
set "BASENAME=%~n1"
set "FILE_DIR=%~dp1"

REM ============================================================================
REM DETECT: Project Root
REM ============================================================================
set "PROJECT_ROOT=%~2"

if "!PROJECT_ROOT! "=="" (
    echo [INFO] Auto-detecting project root...
    
    REM Method 1: Check for existing sidecar JSON files in chunker output
    REM (These contain source_path metadata from previous processing)
    echo   [INFO] Checking for existing sidecar files...
    for /f "delims=" %%A in ('powershell -Command "[System.Environment]::ExpandEnvironmentVariables('%CHUNKER_OUTPUT%')"') do set "EXPANDED_OUTPUT=%%A"
    
    REM Look for sidecar files that might contain source path hints
    for /f "delims=" %%S in ('powershell -NoProfile -Command "Get-ChildItem -Path '%EXPANDED_OUTPUT%' -Recurse -Filter '*_sidecar.json' -ErrorAction SilentlyContinue | Select-Object -First 5 -ExpandProperty FullName" 2^>nul') do (
        REM Extract source_path from sidecar JSON using PowerShell
        for /f "delims=" %%P in ('powershell -NoProfile -Command "$json = Get-Content '%%S' -Raw -ErrorAction SilentlyContinue | ConvertFrom-Json; if ($json.source_path) { $json.source_path }" 2^>nul') do (
            REM Check if this source path is in a project with docs\chatlogs
            set "SIDECAR_SOURCE=%%P"
            if defined SIDECAR_SOURCE (
                REM Extract directory from source path
                for %%D in ("!SIDECAR_SOURCE!") do set "SIDECAR_DIR=%%~dpD"
                REM Remove trailing backslash
                if "!SIDECAR_DIR:~-1! "=="\" set "SIDECAR_DIR=!SIDECAR_DIR:~0,-1!" REM Walk up from sidecar source to find project root
                set "CHECK_DIR=!SIDECAR_DIR!" :CHECK_SIDECAR_PATH
                if exist "!CHECK_DIR!\docs\chatlogs\" (
                    set "PROJECT_ROOT=!CHECK_DIR!" goto PROJECT_FOUND
                )
                REM Move up one level
                for %%P in ("!CHECK_DIR!") do set "PARENT_DIR=%%~dpP"
                if not "!PARENT_DIR! "=="" (
                    if "!PARENT_DIR:~-1! "=="\" set "PARENT_DIR=!PARENT_DIR:~0,-1!" if not "!PARENT_DIR!"=="!CHECK_DIR!" (
                        set "CHECK_DIR=!PARENT_DIR!" goto CHECK_SIDECAR_PATH
                    )
                )
            )
        )
    )
    
    REM Method 2: Walk up directory tree looking for docs\chatlogs folder
    set "CURRENT_DIR=!FILE_DIR!" :FIND_PROJECT_ROOT
    REM Remove trailing backslash
    if "!CURRENT_DIR:~-1! "=="\" set "CURRENT_DIR=!CURRENT_DIR:~0,-1!" REM Check if docs\chatlogs exists here
    if exist "!CURRENT_DIR!\docs\chatlogs\" (
        set "PROJECT_ROOT=!CURRENT_DIR!" goto PROJECT_FOUND
    )
    
    REM Move up one level
    for %%P in ("!CURRENT_DIR!") do set "PARENT_DIR=%%~dpP"
    if "!PARENT_DIR! "=="" (
        REM Reached root, try one more check at Standards level
        if exist "C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\Standards\docs\chatlogs\" (
            set "PROJECT_ROOT=C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\Standards"
            goto PROJECT_FOUND
        )
        goto PROJECT_NOT_FOUND
    )
    
    REM Remove trailing backslash from parent
    if "!PARENT_DIR:~-1! "=="\" set "PARENT_DIR=!PARENT_DIR:~0,-1!" set "CURRENT_DIR=!PARENT_DIR!" goto FIND_PROJECT_ROOT
    
    :PROJECT_NOT_FOUND
    echo [ERROR] Could not auto-detect project root. echo. echo Detection methods tried:
    echo   1. Existing sidecar JSON files in chunker output
    echo   2. Directory tree walk (looking for docs\chatlogs\)
    echo. echo Please provide project root as second parameter:
    echo   Process_Chatlog.bat "%INPUT_FILE%" "C:\path\to\project"
    echo. echo Or ensure the file is within a project that has: docs\chatlogs\ folder
    pause
    exit /b 1
    
    :PROJECT_FOUND
    echo   [OK] Detected project: !PROJECT_ROOT!
) else (
    echo   [OK] Using provided project root: !PROJECT_ROOT!
) REM Set project-specific paths
set "RAW_DIR=!PROJECT_ROOT!\docs\chatlogs\raw"
set "CHUNKED_DIR=!PROJECT_ROOT!\docs\chatlogs\chunked"

REM Extract project name for display
for %%P in ("!PROJECT_ROOT!") do set "PROJECT_NAME=%%~nxP"

echo. echo ============================================================================
echo  CHATLOG PROCESSOR v2.0.0 - !PROJECT_NAME! echo ============================================================================
echo. echo Processing: %FILENAME%
echo Project:    !PROJECT_ROOT! echo. REM Check if watcher is running
echo [STEP 0/5] Checking watcher status...
powershell -NoProfile -Command "$watcher = Get-Process python -ErrorAction SilentlyContinue | Where-Object { try { $cmdLine = (Get-WmiObject Win32_Process -Filter \"ProcessId = $($_.Id)\" -ErrorAction SilentlyContinue).CommandLine; $cmdLine -like '*watcher_splitter.py*' } catch { $false } }; if ($watcher) { exit 0 } else { exit 1 }" >nul 2>&1
if errorlevel 1 (
    echo   [WARNING] Watcher may not be running! echo   Please ensure watcher is running: python watcher_splitter.py
    echo   Continuing anyway...
    echo.
) else (
    echo   [OK] Watcher is running
    echo.
) REM ============================================================================
REM STEP 1: Move to Project Raw Folder
REM ============================================================================
echo [STEP 1/5] Saving to project raw folder...

if not exist "!RAW_DIR!" mkdir "!RAW_DIR!" if /i "%~dp1"=="!RAW_DIR!\" (
    echo   [INFO] File is already in raw folder.
) else (
    move /Y "%INPUT_FILE%" "!RAW_DIR!\" >nul
    if errorlevel 1 (
        echo ERROR: Failed to move to raw folder. pause
        exit /b 1
    )
    echo   [OK] Saved to: docs\chatlogs\raw\%FILENAME%
)

REM ============================================================================
REM STEP 2: Send Atomic Copy to Chunker
REM ============================================================================
echo. echo [STEP 2/5] Sending atomic copy to chunker...

if not exist "%CHUNKER_INPUT%" (
    echo   [ERROR] Watch folder does not exist: %CHUNKER_INPUT%
    pause
    exit /b 1
)

REM 1. Copy as .part (Watcher ignores this)
copy /Y "!RAW_DIR!\%FILENAME%" "%CHUNKER_INPUT%\%FILENAME%.part" >nul 2>&1
if errorlevel 1 (
    echo   [ERROR] Failed to copy file to watch folder
    pause
    exit /b 1
)

REM 2. Rename to final (Watcher sees ONE event)
ren "%CHUNKER_INPUT%\%FILENAME%.part" "%FILENAME%" >nul 2>&1
if errorlevel 1 (
    echo   [ERROR] Failed to rename file in watch folder
    pause
    exit /b 1
)

echo   [OK] File queued for processing

REM ============================================================================
REM STEP 3: Monitor for Output
REM ============================================================================
echo. echo [STEP 3/5] Waiting for processed files...
echo   Target: %BASENAME%...
echo   Timeout: 180 seconds (scanning every 5 seconds)
echo. REM Expand environment variables in output path
for /f "delims=" %%A in ('powershell -Command "[System.Environment]::ExpandEnvironmentVariables('%CHUNKER_OUTPUT%')"') do set "EXPANDED_OUTPUT=%%A"

set "TIMEOUT_COUNT=0"
set "FOUND_PATH="
set "SCAN_INTERVAL=5"
set "MAX_SCANS=36"

:WAIT_FOR_CHUNK
timeout /t %SCAN_INTERVAL% /nobreak >nul
set /a TIMEOUT_COUNT+=1
set /a ELAPSED=TIMEOUT_COUNT * %SCAN_INTERVAL%

REM Show progress every 10 seconds
set /a MOD_CHECK=%TIMEOUT_COUNT% %% 2
if %MOD_CHECK%==0 echo   ...scanning (%ELAPSED%s)

REM Look for a DIRECTORY containing the basename
for /d %%D in ("%EXPANDED_OUTPUT%\*%BASENAME%*") do (
    REM Check if chunks exist in the directory
    dir /b "%%D\chunk_*.txt" >nul 2>&1
    if not errorlevel 1 (
        set "FOUND_PATH=%%D"
        goto FILES_FOUND
    )
)

REM Wait max 180 seconds (36 scans * 5 seconds)
if %TIMEOUT_COUNT% lss %MAX_SCANS% goto WAIT_FOR_CHUNK

echo. echo [ERROR] Chunking Timed Out
echo The watcher may be busy or the file is very large. echo. echo Diagnostics:
echo   - Timeout: 180 seconds
echo   - Watch folder: %CHUNKER_INPUT%
echo   - Output folder: %EXPANDED_OUTPUT%
echo   - Target file: %BASENAME%
echo. echo Troubleshooting:
echo   1. Check if watcher is running: python watcher_splitter.py
echo   2. Check watch folder for queued files: %CHUNKER_INPUT%
echo   3. Check if file was copied: dir "%CHUNKER_INPUT%\%FILENAME%"
echo   4. Check output folder: %EXPANDED_OUTPUT%
echo   5.