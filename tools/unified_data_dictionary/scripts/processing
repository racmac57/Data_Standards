@echo off
REM ============================================================================
REM Process Chatlog (Portable - Auto-detects workspace)
REM ============================================================================
REM Version: 1.3.0 (Fixed directory detection, added numbered structure support, improved error handling)
REM ============================================================================
REM This script processes chatlogs and saves copies to the workspace where
REM the file was exported from (detects code-workspace location).
REM Also saves a copy to unified_data_dictionary for archival.
REM ============================================================================

setlocal enabledelayedexpansion

REM External paths (shared across all projects)
set "CHUNKER_ROOT=C:\_chunker\opus"
set "CHUNKER_INPUT=C:\_chunker\02_data"
set "CHUNKER_OUTPUT=C:\Users\carucci_r\OneDrive - City of Hackensack\KB_Shared\04_output"
set "ONEDRIVE_ROOT=C:\Users\carucci_r\OneDrive - City of Hackensack"

REM UDD paths (for archival copy)
set "UDD_ROOT=%ONEDRIVE_ROOT%\09_Reference\Standards\unified_data_dictionary"
set "UDD_RAW_DIR=%UDD_ROOT%\docs\chatlogs\raw"
set "UDD_CHUNKED_DIR=%UDD_ROOT%\docs\chatlogs\chunked"

REM Debug mode (enable with -v or --verbose as second parameter)
set "DEBUG_MODE=0"
if "%2"=="-v" set "DEBUG_MODE=1"
if "%2"=="--verbose" set "DEBUG_MODE=1"
if !DEBUG_MODE!==1 echo [DEBUG] Debug mode enabled

REM Activity log
set "LOG_FILE=%ONEDRIVE_ROOT%\chatlog_processor.log"

REM ============================================================================
REM CHECK: File Selection
REM ============================================================================
if "%~1"=="" (
    echo [ERROR] No file selected.
    pause
    exit /b 1
)

REM Check if multiple files were selected
set "FILE_COUNT=0"
set "MULTI_FILE=0"
for %%A in (%*) do set /a FILE_COUNT+=1
if !FILE_COUNT! gtr 1 (
    set "MULTI_FILE=1"
    echo.
    echo ============================================================================
    echo  PROCESSING MULTIPLE FILES: !FILE_COUNT! files selected
    echo ============================================================================
    echo.
    REM Process each file sequentially
    REM Use shift-based loop to handle paths with spaces properly
    set "PROCESSED=0"
    set "FAILED=0"
    
    :MULTI_LOOP
    if "%~1"=="" goto :MULTI_DONE
    call :PROCESS_SINGLE_FILE "%~1"
    if !errorlevel!==0 (
        set /a PROCESSED+=1
    ) else (
        set /a FAILED+=1
    )
    shift
    goto :MULTI_LOOP
    
    :MULTI_DONE
    echo.
    echo ============================================================================
    echo  MULTI-FILE PROCESSING COMPLETE
    echo ============================================================================
    echo.
    echo Processed: !PROCESSED! files
    echo Failed: !FAILED! files
    echo.
    call :LOG_ACTIVITY "Multi-file processing complete: !PROCESSED! processed, !FAILED! failed"
    timeout /t 3 /nobreak >nul
    exit /b 0
)

REM Single file processing - continue with original logic below
set "MULTI_FILE=0"
set "INPUT_FILE=%~1"
set "FILENAME=%~nx1"
set "BASENAME=%~n1"
set "FILE_DIR=%~dp1"
goto :MAIN_PROCESSING

:PROCESS_SINGLE_FILE
REM Process a single file (called from multiple file loop)
REM Reset all variables for this file
set "INPUT_FILE=%~1"
set "FILENAME=%~nx1"
set "BASENAME=%~n1"
set "FILE_DIR=%~dp1"
set "FOUND_PATH="
set "SOURCE_DIR="
set "TIMESTAMPED_FOLDER="
set "DEST_PATH="
set "CHUNK_COUNT=0"
set "COPIED_COUNT=0"
set "ELAPSED="
set "TIMEOUT_COUNT=0"
REM Add these to prevent variable bleed between files:
set "DOCS_BASE="
set "RAW_DIR="
set "CHUNKED_DIR="
set "PROJECT_ROOT="
set "PROJECT_NAME="
set "USE_DIRECT_COPY="

REM Continue with main processing logic
goto :MAIN_PROCESSING

:MAIN_PROCESSING

REM ============================================================================
REM STEP 0: Detect Workspace Location
REM ============================================================================
echo.
echo [STEP 0/7] Detecting workspace location...

REM Check if file is in a system directory (Downloads, Desktop, etc.)
set "IS_SYSTEM_DIR=0"
if /i "%FILE_DIR:~0,19%"=="C:\Users\carucci_r\" (
    for %%D in ("Downloads" "Desktop" "Documents") do (
        if /i "!FILE_DIR!"=="C:\Users\carucci_r\%%D\" set "IS_SYSTEM_DIR=1"
    )
)

if !IS_SYSTEM_DIR!==1 (
    echo   [INFO] File is in a system directory, searching for project workspace...
    echo   [INFO] Searching for OneDrive project directories...
    
    REM Search for .code-workspace files in common project locations
    set "WORKSPACE_FOUND=0"
    
    REM Extract keywords from filename to match project directories
    set "SEARCH_KEYWORD="
    for %%W in (%BASENAME:_= %) do (
        if "!SEARCH_KEYWORD!"=="" set "SEARCH_KEYWORD=%%W"
    )
    
    REM Search in common project directories
    for %%P in (
        "%ONEDRIVE_ROOT%\01_DataSources"
        "%ONEDRIVE_ROOT%\02_ETL_Scripts"
        "%ONEDRIVE_ROOT%\00_dev"
    ) do (
        if exist "%%P" (
            for /f "delims=" %%D in ('dir /b /ad "%%P" 2^>nul') do (
                REM Check if directory name matches keyword or has .code-workspace
                echo %%D | findstr /i "!SEARCH_KEYWORD!" >nul 2>&1
                if !errorlevel!==0 (
                    if exist "%%P\%%D\*.code-workspace" (
                        set "PROJECT_ROOT=%%P\%%D"
                        set "WORKSPACE_FOUND=1"
                        goto WORKSPACE_DETECTED
                    )
                )
                REM Also check for .code-workspace files
                if exist "%%P\%%D\*.code-workspace" (
                    set "PROJECT_ROOT=%%P\%%D"
                    set "WORKSPACE_FOUND=1"
                    goto WORKSPACE_DETECTED
                )
            )
        )
    )
    
    REM If not found, default to file's directory
    if !WORKSPACE_FOUND!==0 (
        set "PROJECT_ROOT=!FILE_DIR!"
        echo   [INFO] Using file directory as workspace
    )
) else (
    REM File is in a project directory - use it as workspace
    REM Walk up to find project root (look for .code-workspace, .git, or scripts folder)
    set "CURRENT_DIR=!FILE_DIR!"
    set "PROJECT_ROOT="
    
    :FIND_WORKSPACE
    REM Remove trailing backslash
    if "!CURRENT_DIR:~-1!"=="\" set "CURRENT_DIR=!CURRENT_DIR:~0,-1!"
    
    REM Check for project markers
    if exist "!CURRENT_DIR!\.code-workspace" (
        set "PROJECT_ROOT=!CURRENT_DIR!"
        goto WORKSPACE_DETECTED
    )
    if exist "!CURRENT_DIR!\.git" (
        set "PROJECT_ROOT=!CURRENT_DIR!"
        goto WORKSPACE_DETECTED
    )
    if exist "!CURRENT_DIR!\scripts" (
        set "PROJECT_ROOT=!CURRENT_DIR!"
        goto WORKSPACE_DETECTED
    )
    if exist "!CURRENT_DIR!\README.md" (
        set "PROJECT_ROOT=!CURRENT_DIR!"
        goto WORKSPACE_DETECTED
    )
    
    REM Move up one level
    for %%P in ("!CURRENT_DIR!") do set "PARENT_DIR=%%~dpP"
    if "!PARENT_DIR!"=="" goto WORKSPACE_NOT_FOUND
    
    REM Remove trailing backslash from parent
    set "PARENT_DIR_CLEAN=!PARENT_DIR!"
    if "!PARENT_DIR_CLEAN:~-1!"=="\" set "PARENT_DIR_CLEAN=!PARENT_DIR_CLEAN:~0,-1!"
    
    REM Stop if we've reached the root drive
    REM Check if current is already a root (just drive letter like "C:")
    set "CURRENT_CLEAN=!CURRENT_DIR!"
    if "!CURRENT_CLEAN:~-1!"=="\" set "CURRENT_CLEAN=!CURRENT_CLEAN:~0,-1!"
    
    REM If current is just a drive letter, stop (we're at root)
    if "!CURRENT_CLEAN:~2!"=="" (
        REM Check if it's format "C:" (2 characters)
        if "!CURRENT_CLEAN:~1,1!"==":" goto WORKSPACE_NOT_FOUND
    )
    
    REM If parent is empty or invalid, stop
    if "!PARENT_DIR_CLEAN!"=="" goto WORKSPACE_NOT_FOUND
    
    REM If parent is same as current (shouldn't happen), stop
    if /i "!PARENT_DIR_CLEAN!"=="!CURRENT_CLEAN!" goto WORKSPACE_NOT_FOUND
    
    REM If parent is just a drive letter, we've reached root - stop
    if "!PARENT_DIR_CLEAN:~2!"=="" (
        if "!PARENT_DIR_CLEAN:~1,1!"==":" goto WORKSPACE_NOT_FOUND
    )
    
    REM Continue walking up
    set "CURRENT_DIR=!PARENT_DIR_CLEAN!"
    goto FIND_WORKSPACE
)

:LOG_ACTIVITY
REM Usage: call :LOG_ACTIVITY "message"
echo %DATE% %TIME% - %~1 >> "%LOG_FILE%" 2>nul
exit /b 0

:HANDLE_CHUNKER_SPECIAL_CASE
REM Special handling for C:\_chunker project (always uses "docs")
REM Use exact match (not case-insensitive) to prevent false matches like "C:"
if "!PROJECT_ROOT!"=="C:\_chunker" (
    set "DOCS_BASE=docs"
    set "RAW_DIR=!PROJECT_ROOT!\docs\raw"
    set "CHUNKED_DIR=!PROJECT_ROOT!\docs\chunked"
    if !DEBUG_MODE!==1 echo [DEBUG] Using chunker special case: docs
    exit /b 0
)
exit /b 1

:CHECK_NUMBERED_STRUCTURE
REM Check if project uses numbered folder prefixes (e.g., 01_scripts, 02_data)
REM Returns: errorlevel 0 if numbered structure detected, 1 if not
if !DEBUG_MODE!==1 echo [DEBUG] Checking for numbered folder structure in: !PROJECT_ROOT!

set "NUMBERED_COUNT=0"
set "TOTAL_COUNT=0"

REM Minimum 3 folders required to determine pattern
for /f "delims=" %%D in ('dir /b /ad "!PROJECT_ROOT!" 2^>nul') do (
    set /a TOTAL_COUNT+=1
)

if !DEBUG_MODE!==1 echo [DEBUG] Total folders found: !TOTAL_COUNT!

if !TOTAL_COUNT! lss 3 (
    if !DEBUG_MODE!==1 echo [DEBUG] Not enough folders to determine pattern
    exit /b 1
)

REM Count folders with numbered prefixes
for /f "delims=" %%D in ('dir /b /ad "!PROJECT_ROOT!" 2^>nul') do (
    echo %%D | findstr /r "^[0-9][0-9]_" >nul 2>&1
    if !errorlevel!==0 (
        set /a NUMBERED_COUNT+=1
        if !DEBUG_MODE!==1 echo [DEBUG] Numbered folder: %%D
    )
)

if !DEBUG_MODE!==1 echo [DEBUG] Numbered folders: !NUMBERED_COUNT! / !TOTAL_COUNT!

REM If >50% of folders use numbering, consider it numbered structure
set /a THRESHOLD=TOTAL_COUNT / 2
if !NUMBERED_COUNT! gtr !THRESHOLD! (
    if !DEBUG_MODE!==1 echo [DEBUG] Numbered structure detected
    exit /b 0
)
if !DEBUG_MODE!==1 echo [DEBUG] Standard structure detected
exit /b 1

:DETECT_DOCS_DIRECTORY
REM Unified function to detect or determine docs directory structure
REM Sets: DOCS_BASE, RAW_DIR, CHUNKED_DIR
REM Priority: 1) docs (preferred), 2) doc/Doc/Docs variants, 3) numbered variants, 4) create new

REM Validate PROJECT_ROOT
if "!PROJECT_ROOT!"=="" (
    echo [ERROR] PROJECT_ROOT not set, cannot detect docs directory
    exit /b 1
)
if not exist "!PROJECT_ROOT!" (
    echo [ERROR] PROJECT_ROOT does not exist: !PROJECT_ROOT!
    exit /b 1
)

set "DOCS_BASE="

REM Priority 1: Check for "docs" (lowercase, plural) - PREFERRED
if !DEBUG_MODE!==1 echo [DEBUG] Checking for: !PROJECT_ROOT!\docs
if exist "!PROJECT_ROOT!\docs" (
    set "DOCS_BASE=docs"
    goto DOCS_DIRECTORY_FOUND
)

REM Priority 2: Check for doc/docs variants (case-insensitive using DIR)
if !DEBUG_MODE!==1 echo [DEBUG] Checking for doc/docs variants
for /f "delims=" %%D in ('dir /b /ad "!PROJECT_ROOT!" 2^>nul') do (
    if !DEBUG_MODE!==1 echo [DEBUG] Found directory: %%D
    if /i "%%D"=="docs" (
        set "DOCS_BASE=%%D"
        goto DOCS_DIRECTORY_FOUND
    )
    if /i "%%D"=="doc" (
        set "DOCS_BASE=%%D"
        goto DOCS_DIRECTORY_FOUND
    )
)

REM Priority 3: Check for numbered variants (case-insensitive)
for /f "delims=" %%D in ('dir /b /ad "!PROJECT_ROOT!" 2^>nul ^| findstr /r /i "^[0-9][0-9]_doc"') do (
    if "!DOCS_BASE!"=="" (
        set "DOCS_BASE=%%D"
        goto DOCS_DIRECTORY_FOUND
    )
)

REM Priority 4: No existing directory found - determine what to create
call :CHECK_NUMBERED_STRUCTURE
if !errorlevel!==0 (
    REM Project uses numbered structure - find next available prefix
    set "MAX_PREFIX=0"
    for /f "tokens=1 delims=_" %%N in ('dir /b /ad "!PROJECT_ROOT!" 2^>nul ^| findstr /r "^[0-9][0-9]_"') do (
        if %%N gtr !MAX_PREFIX! set "MAX_PREFIX=%%N"
    )
    set /a NEW_PREFIX=MAX_PREFIX + 10
    if !NEW_PREFIX! lss 40 set "NEW_PREFIX=40"
    set "DOCS_BASE=!NEW_PREFIX!_docs"
    echo   [INFO] Detected numbered folder structure, using: !DOCS_BASE!
) else (
    REM Standard structure - create docs (plural)
    set "DOCS_BASE=docs"
    echo   [INFO] No existing doc/docs structure found, using standard: docs
)
goto DOCS_DIRECTORY_SET

:DOCS_DIRECTORY_FOUND
echo   [INFO] Found existing directory structure: !DOCS_BASE!

:DOCS_DIRECTORY_SET
set "RAW_DIR=!PROJECT_ROOT!\!DOCS_BASE!\raw"
set "CHUNKED_DIR=!PROJECT_ROOT!\!DOCS_BASE!\chunked"
exit /b 0

:WORKSPACE_DETECTED
REM Set project-specific paths (detect existing doc/docs structure first)
call :HANDLE_CHUNKER_SPECIAL_CASE
if !errorlevel!==0 (
    echo   [OK] Workspace: !PROJECT_ROOT! (chunker project)
    echo   [OK] Raw dir: !DOCS_BASE!\raw
    echo   [OK] Chunked dir: !DOCS_BASE!\chunked
    call :LOG_ACTIVITY "Detected chunker project: !PROJECT_ROOT!"
) else (
    call :DETECT_DOCS_DIRECTORY
    if !errorlevel!==0 (
        echo   [OK] Workspace: !PROJECT_ROOT!
        echo   [OK] Raw dir: !DOCS_BASE!\raw
        echo   [OK] Chunked dir: !DOCS_BASE!\chunked
        call :LOG_ACTIVITY "Detected directory structure: !DOCS_BASE!"
    ) else (
        echo   [ERROR] Failed to detect docs directory structure
        pause
        exit /b 1
    )
)
goto WORKSPACE_SET

:WORKSPACE_NOT_FOUND
REM Fallback to file's directory
set "PROJECT_ROOT=!FILE_DIR!"
call :HANDLE_CHUNKER_SPECIAL_CASE
if !errorlevel!==0 (
    REM Chunker case handled
    echo   [WARNING] Could not detect workspace, using file directory (chunker)
    call :LOG_ACTIVITY "Chunker project detected (fallback): !PROJECT_ROOT!"
) else (
    call :DETECT_DOCS_DIRECTORY
    if !errorlevel!==0 (
        echo   [WARNING] Could not detect workspace, using file directory
        call :LOG_ACTIVITY "Detected directory structure (fallback): !DOCS_BASE!"
    ) else (
        echo   [ERROR] Failed to detect docs directory structure
        pause
        exit /b 1
    )
)
goto WORKSPACE_SET

:WORKSPACE_SET
REM Extract project name for display
for %%P in ("!PROJECT_ROOT!") do set "PROJECT_NAME=%%~nxP"

REM Log processing start
call :LOG_ACTIVITY "Processing: %FILENAME% in project: !PROJECT_NAME!"

echo.
echo ============================================================================
echo  PORTABLE CHATLOG PROCESSOR v1.3.0
echo ============================================================================
echo.
echo Processing: %FILENAME%
echo Project:    !PROJECT_NAME!
echo.

REM ============================================================================
REM STEP 1: Check Watcher Status
REM ============================================================================
echo [STEP 1/7] Checking watcher status...
powershell -NoProfile -Command "$watcher = Get-Process python -ErrorAction SilentlyContinue | Where-Object { try { $cmdLine = (Get-WmiObject Win32_Process -Filter \"ProcessId = $($_.Id)\" -ErrorAction SilentlyContinue).CommandLine; $cmdLine -like '*watcher_splitter.py*' } catch { $false } }; if ($watcher) { exit 0 } else { exit 1 }" >nul 2>&1
if errorlevel 1 (
    echo   [WARNING] Watcher may not be running!
    echo   Please ensure watcher is running: python watcher_splitter.py
    echo   Continuing anyway...
    echo.
) else (
    echo   [OK] Watcher is running
    echo.
)

REM ============================================================================
REM STEP 2: Save Copy to Workspace Raw Folder
REM ============================================================================
echo [STEP 2/7] Saving to workspace raw folder...

REM Create directory structure if it doesn't exist (parent and child)
REM Extract parent directory (docs/doc) from RAW_DIR (e.g., C:\...\docs\raw -> C:\...\docs\)
for %%P in ("!RAW_DIR!") do set "RAW_PARENT=%%~dpP"
REM Remove trailing backslash for cleaner display
set "RAW_PARENT_DISP=!RAW_PARENT!"
if "!RAW_PARENT_DISP:~-1!"=="\" set "RAW_PARENT_DISP=!RAW_PARENT_DISP:~0,-1!"
REM Check if parent directory exists and create if needed
if not exist "!RAW_PARENT!" (
    echo   [INFO] Creating parent directory: !RAW_PARENT_DISP!
    powershell -NoProfile -Command "New-Item -ItemType Directory -Path '!RAW_PARENT!' -Force | Out-Null" >nul 2>&1
)
if not exist "!RAW_DIR!" (
    echo   [INFO] Creating directory structure: !DOCS_BASE!\raw
    powershell -NoProfile -Command "New-Item -ItemType Directory -Path '!RAW_DIR!' -Force | Out-Null" >nul 2>&1
    if errorlevel 1 (
        echo   [ERROR] Failed to create directory: !RAW_DIR!
        pause
        exit /b 1
    )
)

REM Move file to raw folder (moves original from workspace root)
if /i "%~dp1"=="!PROJECT_ROOT!\" (
    REM File is in workspace root - move it
    move /Y "%INPUT_FILE%" "!RAW_DIR!\%FILENAME%" >nul 2>&1
    if errorlevel 0 (
        echo   [OK] Moved to: !DOCS_BASE!\raw\%FILENAME%
    ) else (
        echo   [ERROR] Failed to move to raw folder
        pause
        exit /b 1
    )
) else (
    REM File is elsewhere (Downloads, etc.) - copy it
    copy /Y "%INPUT_FILE%" "!RAW_DIR!\%FILENAME%" >nul 2>&1
    if errorlevel 0 (
        echo   [OK] Saved copy to: !DOCS_BASE!\raw\%FILENAME%
    ) else (
        echo   [ERROR] Failed to copy to raw folder
        pause
        exit /b 1
    )
)

REM ============================================================================
REM STEP 3: Save Copy to UDD for Archival
REM ============================================================================
echo.
echo [STEP 3/7] Saving archival copy to unified_data_dictionary...

REM Create UDD directories if they don't exist
if not exist "%UDD_RAW_DIR%" (
    powershell -NoProfile -Command "New-Item -ItemType Directory -Path '%UDD_RAW_DIR%' -Force | Out-Null" >nul 2>&1
)

REM Copy to UDD (archival)
copy /Y "%INPUT_FILE%" "%UDD_RAW_DIR%\%FILENAME%" >nul 2>&1
if errorlevel 0 (
    echo   [OK] Saved archival copy to: unified_data_dictionary\docs\chatlogs\raw\
) else (
    echo   [WARNING] Failed to save archival copy (continuing anyway)
)

REM ============================================================================
REM STEP 4: Send Atomic Copy to Chunker
REM ============================================================================
echo.
echo [STEP 4/7] Sending atomic copy to chunker...

if not exist "%CHUNKER_INPUT%" (
    echo   [ERROR] Watch folder does not exist: %CHUNKER_INPUT%
    pause
    exit /b 1
)

REM Check if file already exists in watch folder
if exist "%CHUNKER_INPUT%\%FILENAME%" (
    echo   [WARNING] File already exists in watch folder, removing old copy...
    del /F /Q "%CHUNKER_INPUT%\%FILENAME%" >nul 2>&1
)

REM 1. Copy as .part (Watcher ignores this)
copy /Y "!RAW_DIR!\%FILENAME%" "%CHUNKER_INPUT%\%FILENAME%.part" >nul 2>&1
if errorlevel 1 (
    echo   [ERROR] Failed to copy file to watch folder
    pause
    exit /b 1
)

REM 2. Rename to final .md (Watcher sees ONE event)
timeout /t 1 /nobreak >nul
ren "%CHUNKER_INPUT%\%FILENAME%.part" "%FILENAME%" >nul 2>&1
if errorlevel 1 (
    echo   [WARNING] Failed to rename file in watch folder
    echo   Watcher may still process the .part file
)

echo   [OK] File queued for processing

REM ============================================================================
REM STEP 5: Monitor for Output
REM ============================================================================
echo.
echo [STEP 5/7] Waiting for processed files...
echo   Target: %BASENAME%...
echo   Timeout: 300 seconds (scanning every 5 seconds)
echo.

set "TIMEOUT_COUNT=0"
set "FOUND_PATH="
set "SCAN_INTERVAL=5"
set "MAX_SCANS=60"

:WAIT_FOR_CHUNK
timeout /t %SCAN_INTERVAL% /nobreak >nul
set /a TIMEOUT_COUNT+=1
set /a ELAPSED=TIMEOUT_COUNT * %SCAN_INTERVAL%

REM Show progress every 10 seconds
set /a MOD_CHECK=%TIMEOUT_COUNT% %% 2
if %MOD_CHECK%==0 echo   ...scanning (!ELAPSED!s / 300s)

REM Look for a DIRECTORY containing the basename in output (this is the reliable indicator of processing)
REM Don't check watch folder existence - file stays there until AFTER processing completes
for /d %%D in ("%CHUNKER_OUTPUT%\*%BASENAME%*") do (
    REM Check if chunks exist in the directory
    dir /b "%%D\chunk_*.txt" >nul 2>&1
    if not errorlevel 1 (
        set "FOUND_PATH=%%D"
        goto FILES_FOUND
    )
)

REM If no output found yet and first check, provide helpful status
if %TIMEOUT_COUNT%==1 (
    if exist "%CHUNKER_INPUT%\%FILENAME%" (
        echo   [INFO] File queued in watch folder, waiting for processing to start...
    ) else (
        echo   [INFO] File may have been processed already, scanning for output...
    )
)

REM Wait max 300 seconds (60 scans * 5 seconds)
if %TIMEOUT_COUNT% lss %MAX_SCANS% goto WAIT_FOR_CHUNK

echo.
echo [WARNING] Chunking output not found after 300 seconds
echo The watcher may still be processing. Checking for existing files...
goto CHECK_EXISTING

:FILES_FOUND
if not exist "%CHUNKER_INPUT%\%FILENAME%" (
    echo   [INFO] File removed from watch folder - checking for output...
)
echo   [OK] Found output: %FOUND_PATH%

REM ============================================================================
REM STEP 6: Verify Chunks
REM ============================================================================
:CHECK_EXISTING
echo.
echo [STEP 6/7] Verifying chunks...

if defined FOUND_PATH (
    set "SOURCE_DIR=!FOUND_PATH!"
) else (
    REM Try to find existing output
    for /d %%D in ("%CHUNKER_OUTPUT%\*%BASENAME%*") do (
        set "SOURCE_DIR=%%D"
        goto VERIFY_CHUNKS
    )
    echo   [ERROR] Could not find processed files
    echo   Check: %CHUNKER_OUTPUT%
    pause
    exit /b 1
)

:VERIFY_CHUNKS
set "CHUNK_COUNT=0"
for /f %%C in ('dir /b "!SOURCE_DIR!\chunk_*.txt" 2^>nul ^| find /c /v ""') do set "CHUNK_COUNT=%%C"
if !CHUNK_COUNT! gtr 0 (
    echo   [OK] Found !CHUNK_COUNT! chunk files
) else (
    echo   [WARNING] No chunk files found, but directory exists
)

REM ============================================================================
REM STEP 7: Copy Output to Workspace and UDD
REM ============================================================================
echo.
echo [STEP 7/7] Copying files to workspace and UDD...

REM Create directory structure if it doesn't exist (parent and child)
REM Extract parent directory (docs/doc) from CHUNKED_DIR (e.g., C:\...\docs\chunked -> C:\...\docs\)
for %%P in ("!CHUNKED_DIR!") do set "CHUNKED_PARENT=%%~dpP"
REM Remove trailing backslash for cleaner display
set "CHUNKED_PARENT_DISP=!CHUNKED_PARENT!"
if "!CHUNKED_PARENT_DISP:~-1!"=="\" set "CHUNKED_PARENT_DISP=!CHUNKED_PARENT_DISP:~0,-1!"
REM Check if parent directory exists and create if needed
if not exist "!CHUNKED_PARENT!" (
    echo   [INFO] Creating parent directory: !CHUNKED_PARENT_DISP!
    powershell -NoProfile -Command "New-Item -ItemType Directory -Path '!CHUNKED_PARENT!' -Force | Out-Null" >nul 2>&1
)
if not exist "!CHUNKED_DIR!" (
    echo   [INFO] Creating directory structure: !DOCS_BASE!\chunked
    powershell -NoProfile -Command "New-Item -ItemType Directory -Path '!CHUNKED_DIR!' -Force | Out-Null" >nul 2>&1
    if errorlevel 1 (
        echo   [ERROR] Failed to create directory: !CHUNKED_DIR!
        echo   [WARNING] Continuing anyway - files may not be copied back to workspace
    )
)

REM Organize by source filename: chunked\BASENAME\TIMESTAMPED_FOLDER\
REM Extract just the folder name from SOURCE_DIR (e.g., "2026_01_05_21_03_37_filename" or just "filename")
for %%F in ("!SOURCE_DIR!") do set "TIMESTAMPED_FOLDER=%%~nxF"

REM Check if folder name is just the basename (no timestamp prefix)
REM If it matches basename exactly, copy contents directly (no double nesting)
REM Otherwise, create nested structure with timestamped folder
if /i "!TIMESTAMPED_FOLDER!"=="!BASENAME!" (
    REM Folder name IS the basename - copy contents directly to avoid double nesting
    set "DEST_PATH=!CHUNKED_DIR!\!BASENAME!"
    set "USE_DIRECT_COPY=1"
) else (
    REM Folder name has timestamp or is different - use nested structure
    set "SOURCE_FOLDER=!CHUNKED_DIR!\!BASENAME!"
    set "DEST_PATH=!SOURCE_FOLDER!\!TIMESTAMPED_FOLDER!"
    set "USE_DIRECT_COPY=0"
)

REM Create destination directory if it doesn't exist
if not exist "!DEST_PATH!" (
    echo   [INFO] Creating folder: !DEST_PATH!
    powershell -NoProfile -Command "New-Item -ItemType Directory -Path '!DEST_PATH!' -Force | Out-Null" >nul 2>&1
)

REM Copy using PowerShell (more reliable than xcopy for large files)
echo   Copying chunked files to workspace...

REM Ensure destination directory exists
powershell -NoProfile -Command "New-Item -ItemType Directory -Path '!DEST_PATH!' -Force | Out-Null" >nul 2>&1

REM Copy with error handling
powershell -NoProfile -Command "$ErrorActionPreference='Stop'; try { Copy-Item -Path '!SOURCE_DIR!\*' -Destination '!DEST_PATH!\' -Recurse -Force; Write-Host 'SUCCESS' } catch { Write-Host 'ERROR:' $_.Exception.Message; exit 1 }" >nul 2>&1
set "COPY_RESULT=!errorlevel!"

REM Allow file system to sync before verification (fixes timing issues)
timeout /t 1 /nobreak >nul 2>&1

REM Verify files were copied - use PowerShell for more reliable file existence check
set "COPIED_COUNT=0"
for /f %%C in ('powershell -NoProfile -Command "(Get-ChildItem -Path '!DEST_PATH!' -Filter 'chunk_*.txt' -ErrorAction SilentlyContinue).Count"') do set "COPIED_COUNT=%%C"

REM Also check source directory to verify files exist there
set "SOURCE_COUNT=0"
for /f %%C in ('powershell -NoProfile -Command "(Get-ChildItem -Path '!SOURCE_DIR!' -Filter 'chunk_*.txt' -ErrorAction SilentlyContinue).Count"') do set "SOURCE_COUNT=%%C"

if !COPIED_COUNT! gtr 0 (
    REM Success - files were copied and verified
    if !USE_DIRECT_COPY!==1 (
        echo   [OK] Copied !COPIED_COUNT! files to: !DOCS_BASE!\chunked\!BASENAME!
    ) else (
        echo   [OK] Copied !COPIED_COUNT! files to: !DOCS_BASE!\chunked\!BASENAME!\!TIMESTAMPED_FOLDER!
    )
) else if !COPY_RESULT! neq 0 (
    REM PowerShell copy failed - try fallback
    echo   [WARNING] PowerShell copy failed - trying fallback method...
    xcopy "!SOURCE_DIR!" "!DEST_PATH!\" /E /I /Y >nul 2>&1
    if errorlevel 0 (
        REM Allow sync after fallback copy
        timeout /t 1 /nobreak >nul 2>&1
        REM Re-verify after fallback
        set "COPIED_COUNT=0"
        for /f %%C in ('powershell -NoProfile -Command "(Get-ChildItem -Path '!DEST_PATH!' -Filter 'chunk_*.txt' -ErrorAction SilentlyContinue).Count"') do set "COPIED_COUNT=%%C"
        if !COPIED_COUNT! gtr 0 (
            echo   [OK] Files copied using fallback method (!COPIED_COUNT! files)
        ) else (
            echo   [ERROR] Both copy methods failed - files are in: !SOURCE_DIR!
            echo   [INFO] Source has !SOURCE_COUNT! chunk files, destination has !COPIED_COUNT!
            echo   [INFO] You can manually copy from: !SOURCE_DIR!
        )
    ) else (
        echo   [ERROR] Both copy methods failed - files are in: !SOURCE_DIR!
        echo   [INFO] Source has !SOURCE_COUNT! chunk files, destination has !COPIED_COUNT!
        echo   [INFO] You can manually copy from: !SOURCE_DIR!
    )
) else if !SOURCE_COUNT! gtr 0 (
    REM Copy reported success but verification failed - likely timing issue, retry verification
    timeout /t 2 /nobreak >nul 2>&1
    set "COPIED_COUNT=0"
    for /f %%C in ('powershell -NoProfile -Command "(Get-ChildItem -Path '!DEST_PATH!' -Filter 'chunk_*.txt' -ErrorAction SilentlyContinue).Count"') do set "COPIED_COUNT=%%C"
    if !COPIED_COUNT! gtr 0 (
        REM Files found on retry - success
        if !USE_DIRECT_COPY!==1 (
            echo   [OK] Copied !COPIED_COUNT! files to: !DOCS_BASE!\chunked\!BASENAME! (verified on retry)
        ) else (
            echo   [OK] Copied !COPIED_COUNT! files to: !DOCS_BASE!\chunked\!BASENAME!\!TIMESTAMPED_FOLDER! (verified on retry)
        )
    ) else (
        REM Still no files after retry - check if any files were copied at all
        for /f %%C in ('powershell -NoProfile -Command "(Get-ChildItem -Path '!DEST_PATH!' -ErrorAction SilentlyContinue).Count"') do set "ANY_FILES=%%C"
        if !ANY_FILES! gtr 0 (
            echo   [WARNING] Copy completed but no chunk_*.txt files found in destination
            echo   [INFO] Found !ANY_FILES! total files in destination (may include sidecar/transcript files)
            echo   [INFO] Source directory: !SOURCE_DIR! (!SOURCE_COUNT! chunk files)
            echo   [INFO] Destination: !DEST_PATH!
        ) else (
            echo   [ERROR] Copy verification failed - no files found in destination
            echo   [INFO] Source directory: !SOURCE_DIR! (!SOURCE_COUNT! chunk files)
            echo   [INFO] Destination: !DEST_PATH!
        )
    )
) else (
    REM No chunk files in source either - this is a different problem
    echo   [WARNING] No chunk files found in source directory: !SOURCE_DIR!
    echo   [INFO] This may indicate the file was not processed correctly by the chunker
    echo   [INFO] Check the chunker output directory for processing errors
)

REM Also copy to UDD for archival
echo   Copying to unified_data_dictionary for archival...
if not exist "%UDD_CHUNKED_DIR%" (
    powershell -NoProfile -Command "New-Item -ItemType Directory -Path '%UDD_CHUNKED_DIR%' -Force | Out-Null" >nul 2>&1
)

REM Copy to UDD (organized by basename)
set "UDD_DEST=%UDD_CHUNKED_DIR%\!BASENAME!\!TIMESTAMPED_FOLDER!"
if not exist "%UDD_CHUNKED_DIR%\!BASENAME!" (
    powershell -NoProfile -Command "New-Item -ItemType Directory -Path '%UDD_CHUNKED_DIR%\!BASENAME!' -Force | Out-Null" >nul 2>&1
)

powershell -NoProfile -Command "Copy-Item -Path '!SOURCE_DIR!\*' -Destination '%UDD_DEST!\' -Recurse -Force -ErrorAction SilentlyContinue" >nul 2>&1
if errorlevel 0 (
    echo   [OK] Saved archival copy to: unified_data_dictionary\docs\chatlogs\chunked\
) else (
    echo   [WARNING] Failed to save archival copy (continuing anyway)
)

REM ============================================================================
REM STEP 8: Remove Original File from Source Directory (if not in workspace)
REM ============================================================================
REM Only remove if file is still in source directory and processing was successful
if defined SOURCE_DIR (
    REM File was processed successfully - check if original still exists in source
    if exist "%INPUT_FILE%" (
        REM File is still in source directory - remove it
        REM Only remove if it's NOT in the workspace (to preserve workspace files)
        if /i not "!FILE_DIR!"=="!PROJECT_ROOT!\" (
            if /i not "%INPUT_FILE%"=="!RAW_DIR!\%FILENAME%" (
                echo.
                echo [STEP 8/8] Removing original file from source directory...
                del /F /Q "%INPUT_FILE%" >nul 2>&1
                if errorlevel 0 (
                    echo   [OK] Removed: %INPUT_FILE%
                ) else (
                    echo   [WARNING] Could not remove original file (may be in use)
                )
            )
        )
    )
)

REM Only show completion message for single file processing
if "!MULTI_FILE!"=="0" (
    echo.
    echo ============================================================================
    echo  PROCESSING COMPLETE
    echo ============================================================================
    echo.
    echo Workspace:    !PROJECT_ROOT!
    if /i "!PROJECT_ROOT!"=="C:\_chunker" (
        echo Raw Source:   docs\raw\%FILENAME%
        if defined USE_DIRECT_COPY if !USE_DIRECT_COPY!==1 (
            echo Processed:    docs\chunked\!BASENAME!
        ) else (
            echo Processed:    docs\chunked\!BASENAME!\!TIMESTAMPED_FOLDER!
        )
    ) else (
        echo Raw Source:   !DOCS_BASE!\raw\%FILENAME%
        if defined USE_DIRECT_COPY if !USE_DIRECT_COPY!==1 (
            echo Processed:    !DOCS_BASE!\chunked\!BASENAME!
        ) else (
            echo Processed:    !DOCS_BASE!\chunked\!BASENAME!\!TIMESTAMPED_FOLDER!
        )
    )
    echo Chunks:       !CHUNK_COUNT! files
    if defined ELAPSED echo Processing time: ~!ELAPSED! seconds
    echo.
    echo Also saved to unified_data_dictionary for archival.
    echo.
    echo ============================================================================
    call :LOG_ACTIVITY "Completed: %FILENAME% - !CHUNK_COUNT! chunks"
    timeout /t 4 /nobreak >nul
) else (
    REM Multiple file processing - just show brief status
    echo   [OK] Completed: %FILENAME%
)

REM If processing multiple files, return to caller (subroutine)
if "!MULTI_FILE!"=="1" (
    exit /b 0
)

REM Single file processing - exit normally
exit /b 0
