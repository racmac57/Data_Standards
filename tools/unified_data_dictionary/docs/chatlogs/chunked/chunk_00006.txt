#>
    param(
        [object]$ScriptConfig
    )
    
    $scriptName = $ScriptConfig.name
    $validationResults = @()
    $allValid = $true
    
    # Calculate previous month (rolling window typically ends on previous month)
    $now = Get-Date
    $prevMonth = $now.AddMonths(-1)
    $year = $prevMonth.Year
    $month = $prevMonth.Month.ToString("00")
    
    Write-Step "Validating input files for: $scriptName"
    
    switch ($scriptName) {
        "Summons" {
            # New format: YYYY/YYYY_MM_eticket_export.csv
            $eticketBase = "C:\Users\carucci_r\OneDrive - City of Hackensack\05_EXPORTS\_Summons\E_Ticket"
            $eticketPath = Join-Path $eticketBase "$year\$($year)_$($month)_eticket_export.csv"
            
            if (Test-Path $eticketPath) {
                Write-Success "  E-ticket export found: $eticketPath"
                $validationResults += [pscustomobject]@{ File = "E-ticket Export"; Path = $eticketPath; Status = "Found" }
            }
            else {
                Write-Fail "  E-ticket export NOT found: $eticketPath"
                $validationResults += [pscustomobject]@{ File = "E-ticket Export"; Path = $eticketPath; Status = "Missing" }
                $allValid = $false
                
                # Check if directory exists and list available files
                $yearDir = Join-Path $eticketBase $year
                if (Test-Path $yearDir) {
                    $availableFiles = Get-ChildItem -Path $yearDir -Filter "*.csv" -ErrorAction SilentlyContinue
                    if ($availableFiles) {
                        Write-Warn "    Available files in ${yearDir}:"
                        foreach ($file in $availableFiles) {
                            Write-Host "      - $($file.Name)" -ForegroundColor Gray
                        }
                    }
                }
                else {
                    Write-Warn "    Year directory not found: ${yearDir}"
                }
            }
        }
        
        "Response Times" {
            # Format: YYYY/YYYY_MM_Monthly_CAD.xlsx (single .xlsx extension)
            $cadBase = "C:\Users\carucci_r\OneDrive - City of Hackensack\05_EXPORTS\_CAD\monthly_export"
            $cadPath = Join-Path $cadBase "$year\$($year)_$($month)_Monthly_CAD.xlsx"
            
            if (Test-Path $cadPath) {
                Write-Success "  CAD monthly export found: $cadPath"
                $validationResults += [pscustomobject]@{ File = "CAD Monthly Export"; Path = $cadPath; Status = "Found" }
            }
            else {
                Write-Fail "  CAD monthly export NOT found: $cadPath"
                $validationResults += [pscustomobject]@{ File = "CAD Monthly Export"; Path = $cadPath; Status = "Missing" }
                $allValid = $false
                
                # Check if directory exists and list available files
                $yearDir = Join-Path $cadBase $year
                if (Test-Path $yearDir) {
                    $availableFiles = Get-ChildItem -Path $yearDir -Filter "*Monthly_CAD*" -ErrorAction SilentlyContinue
                    if ($availableFiles) {
                        Write-Warn "    Available files in ${yearDir}:"
                        foreach ($file in $availableFiles) {
                            Write-Host "      - $($file.Name)" -ForegroundColor Gray
                        }
                    }
                }
                else {
                    Write-Warn "    Year directory not found: ${yearDir}"
                }
            }
        }
        
        "Overtime TimeOff" {
            # Check for VCS time report exports (if known location)
            $vcsBase = "C:\Users\carucci_r\OneDrive - City of Hackensack\05_EXPORTS"
            $vcsPath = Join-Path $vcsBase "_VCS_Time_Report"
            
            if (Test-Path $vcsPath) {
                Write-Success "  VCS Time Report export directory found: $vcsPath"
                $validationResults += [pscustomobject]@{ File = "VCS Time Report Directory"; Path = $vcsPath; Status = "Found" }
            }
            else {
                Write-Warn "  VCS Time Report export directory not found: $vcsPath (may use different location)"
                $validationResults += [pscustomobject]@{ File = "VCS Time Report Directory"; Path = $vcsPath; Status = "Unknown" }
            }
        }
        
        "Arrests" {
            # Arrests script may have specific input requirements - add if known
            Write-Host "  No specific input file validation configured for Arrests" -ForegroundColor Gray
            $validationResults += [pscustomobject]@{ File = "Arrest Data"; Path = "Unknown"; Status = "Not Validated" }
        }
        
        "Community Engagement" {
            # Community Engagement may have specific input requirements - add if known
            Write-Host "  No specific input file validation configured for Community Engagement" -ForegroundColor Gray
            $validationResults += [pscustomobject]@{ File = "Community Engagement Data"; Path = "Unknown"; Status = "Not Validated" }
        }
        
        default {
            Write-Host "  No input validation configured for: $scriptName" -ForegroundColor Gray
            $validationResults += [pscustomobject]@{ File = "Input Files"; Path = "Unknown"; Status = "Not Validated" }
        }
    }
    
    return @{
        ScriptName = $scriptName
        AllValid   = $allValid
        Results    = $validationResults
    }
}

# Load configuration
if (-not (Test-Path $configPath)) {
    Write-Fail "Configuration file not found: $configPath"
    exit 1
}

$config = Get-Content $configPath | ConvertFrom-Json
$settings = $config.settings
$scripts = $config.scripts | Where-Object { $_.enabled -eq $true } | Sort-Object order

# Filter to specific scripts if requested
if ($ScriptNames.Count -gt 0) {
    $scripts = $scripts | Where-Object { $_.name -in $ScriptNames }
    if ($scripts.Count -eq 0) {
        Write-Fail "No matching enabled scripts found"
        exit 1
    }
}

# Create log directory
$logDir = Join-Path $automationDir $settings.log_directory
if (-not (Test-Path $logDir)) {
    New-Item -ItemType Directory -Path $logDir -Force | Out-Null
}

# Create timestamp
$timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
$logFile = Join-Path $logDir "${timestamp}_ETL_Run.log"

function Write-Log([string]$message) {
    $logMessage = "$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') - $message"
    Add-Content -Path $logFile -Value $logMessage
    Write-Host $message
}

Write-Log "=== Master ETL Orchestrator Started ==="
Write-Log "Timestamp: $timestamp"
Write-Log "Scripts to run: $($scripts.Count)"
Write-Log ""

if ($DryRun) {
    Write-Warn "DRY RUN MODE - No scripts will execute"
    Write-Log "DRY RUN MODE"
}

# Validate input files if requested
if ($ValidateInputs -or $DryRun) {
    Write-Log ""
    Write-Log "=== Input File Validation ==="
    Write-Host ""
    Write-Host "=== Input File Validation ===" -ForegroundColor Cyan
    Write-Host ""
    
    $validationSummary = @()
    $allInputsValid = $true
    
    foreach ($scriptConfig in $scripts) {
        $validation = Test-RequiredInputs -ScriptConfig $scriptConfig
        $validationSummary += $validation
        
        if (-not $validation.AllValid) {
            $allInputsValid = $false
        }
        Write-Host ""
    }
    
    Write-Host "=== Validation Summary ===" -ForegroundColor Cyan
    Write-Log "=== Validation Summary ==="
    
    foreach ($validation in $validationSummary) {
        if ($validation.AllValid) {
            Write-Success "$($validation.ScriptName): All required inputs found"
            Write-Log "$($validation.ScriptName): All required inputs found"
        }
        else {
            Write-Fail "$($validation.ScriptName): Missing required inputs"
            Write-Log "$($validation.ScriptName): Missing required inputs"
            foreach ($result in $validation.Results) {
                if ($result.Status -eq "Missing") {
                    Write-Log "  MISSING: $($result.File) - $($result.Path)"
                }
            }
        }
    }
    
    Write-Host ""
    
    if (-not $allInputsValid) {
        Write-Fail "Some required input files are missing!" Write-Log "Validation failed: Some required input files are missing"
        if (-not $DryRun) {
            Write-Host ""
            Write-Host "You can still proceed, but scripts may fail if inputs are missing." -ForegroundColor Yellow
            $response = Read-Host "Continue anyway? (y/N)"
            if ($response -ne "y" -and $response -ne "Y") {
                Write-Host "Exiting..." -ForegroundColor Yellow
                exit 1
            }
        }
        else {
            Write-Warn "Dry run mode: Fix missing files before running actual ETL"
        }
    }
    else {
        Write-Success "All required input files validated!" Write-Log "Validation passed: All required input files found"
    }
    
    Write-Host ""
    Write-Log ""
    
    # If only validation was requested (without dry run), exit here
    if ($ValidateInputs -and -not $DryRun) {
        Write-Host "Validation complete. Use -DryRun to also preview script execution." -ForegroundColor Cyan
        exit 0
    }
}

# Track results
$results = @()
$startTime = Get-Date

foreach ($scriptConfig in $scripts) {
    $scriptName = $scriptConfig.name
    $scriptPath = $scriptConfig.path
    $scriptFile = $scriptConfig.script
    $fullScriptPath = Join-Path $scriptPath $scriptFile
    
    Write-Log ""
    Write-Step "Processing: $scriptName"
    Write-Log "  Script: $fullScriptPath"
    Write-Log "  Order: $($scriptConfig.order)"
    
    if ($DryRun) {
        Write-Host "  [DRY RUN] Would execute: $fullScriptPath" -ForegroundColor Gray
        continue
    }
    
    # Check if script exists
    if (-not (Test-Path $fullScriptPath)) {
        Write-Fail "  Script not found: $fullScriptPath"
        Write-Log "  ERROR: Script file not found"
        $results += [pscustomobject]@{
            Name     = $scriptName
            Status   = "Failed"
            Error    = "Script file not found"
            Duration = 0
        }
        if (-not $settings.continue_on_error) {
            Write-Fail "Stopping due to error (continue_on_error = false)"
            break
        }
        continue
    }
    
    # Change to script directory
    Push-Location $scriptPath
    
    try {
        $scriptStartTime = Get-Date
        $scriptLogFile = Join-Path $logDir "${timestamp}_${scriptName}.log"
        
        Write-Log "  Executing Python script..."
        Write-Log "  Log: $scriptLogFile"
        
        # Run Python script (cross-version reliable exit codes + stdout/stderr capture)
        $pythonCmd = $settings.python_executable
        $timeoutSeconds = [int]($scriptConfig.timeout_minutes * 60)

        $psi = New-Object System.Diagnostics.ProcessStartInfo
        $psi.FileName = $pythonCmd
        $psi.Arguments = $scriptFile
        $psi.WorkingDirectory = $scriptPath
        $psi.UseShellExecute = $false
        $psi.RedirectStandardOutput = $true
        $psi.RedirectStandardError = $true
        $psi.CreateNoWindow = $true

        $process = New-Object System.Diagnostics.Process
        $process.StartInfo = $psi

        $null = $process.Start()
        $stdoutTask = $process.StandardOutput.ReadToEndAsync()
        $stderrTask = $process.StandardError.ReadToEndAsync()

        if (-not $process.WaitForExit($timeoutSeconds * 1000)) {
            try { $process.Kill() } catch {}
            throw "Script exceeded timeout of $($scriptConfig.timeout_minutes) minutes"
        }
        $process.WaitForExit()

        # Write logs after completion
        $stdoutTask.Result | Out-File -FilePath $scriptLogFile -Encoding utf8
        $stderrTask.Result | Out-File -FilePath "$scriptLogFile.err" -Encoding utf8

        $scriptDuration = (Get-Date) - $scriptStartTime
        $exitCode = $process.ExitCode
        if ($exitCode -eq 0) {
            Write-Success "  Completed in $([math]::Round($scriptDuration.TotalSeconds, 2)) seconds"
            Write-Log "  SUCCESS: Exit code 0"
            
            # Find output files
            # Supports:
            # - Simple patterns like "*.csv" (searched in script root)
            # - Relative subpaths like "output\FIXED_*.csv" (joined to script root)
            $outputFiles = @()
            foreach ($pattern in $scriptConfig.output_patterns) {
                if ([string]::IsNullOrWhiteSpace($pattern)) { continue }

                $isAbsolute = ($pattern -match '^[A-Za-z]:\\' -or $pattern -match '^\\\\')
                $hasSeparator = ($pattern -like "*\*" -or $pattern -like "*/*")

                if ($isAbsolute) {
                    $globPath = $pattern
                    $found = Get-ChildItem -Path $globPath -File -ErrorAction SilentlyContinue
                }
                elseif ($hasSeparator) {
                    $globPath = Join-Path $scriptPath $pattern
                    $found = Get-ChildItem -Path $globPath -File -ErrorAction SilentlyContinue
                }
                else {
                    $found = Get-ChildItem -Path $scriptPath -Filter $pattern -File -ErrorAction SilentlyContinue
                }

                if ($found) { $outputFiles += $found }
            }
            
            Write-Log "  Output files found: $($outputFiles.Count)"
            
            # Copy to Power BI drop folder if enabled
            if ($scriptConfig.output_to_powerbi -and -not $SkipPowerBI) {
                $dropPath = $settings.powerbi_drop_path
                if (-not (Test-Path $dropPath)) {
                    Write-Warn "  Power BI drop folder not found: $dropPath"
                    Write-Log "  WARNING: Power BI drop folder not found"
                }
                else {
                    foreach ($file in $outputFiles) {
                        $destPath = Join-Path $dropPath $file.Name
                        Copy-Item -Path $file.FullName -Destination $destPath -Force
                        Write-Log "  Copied to Power BI: $($file.Name)"
                    }
                    Write-Success "  Copied $($outputFiles.Count) file(s) to Power BI drop folder"
                }
            }
            
            $results += [pscustomobject]@{
                Name        = $scriptName
                Status      = "Success"
                Error       = $null
                Duration    = $scriptDuration.TotalSeconds
                OutputFiles = $outputFiles.Count
            }
        }
        else {
            throw "Script exited with code $exitCode"
        }
        
    }
    catch {
        $scriptDuration = (Get-Date) - $scriptStartTime
        Write-Fail "  Error: $_"
        Write-Log "  ERROR: $_"
        
        $results += [pscustomobject]@{
            Name     = $scriptName
            Status   = "Failed"
            Error    = $_.Exception.Message
            Duration = $scriptDuration.TotalSeconds
        }
        
        if (-not $settings.continue_on_error) {
            Write-Fail "Stopping due to error (continue_on_error = false)"
            break
        }
    }
    finally {
        Pop-Location
    }
}

# Summary
$totalDuration = (Get-Date) - $startTime
$successCount = ($results | Where-Object { $_.Status -eq "Success" }).Count
$failCount = ($results | Where-Object { $_.Status -eq "Failed" }).Count

Write-Log ""
Write-Log "=== Execution Summary ==="
Write-Log "Total duration: $([math]::Round($totalDuration.TotalMinutes, 2)) minutes"
Write-Log "Success: $successCount"
Write-Log "Failed: $failCount"
Write-Log ""

Write-Host ""
Write-Host "=== Execution Summary ===" -ForegroundColor Cyan
Write-Host "Total duration: $([math]::Round($totalDuration.TotalMinutes, 2)) minutes" -ForegroundColor Cyan
Write-Host ""

Write-Host "Results:" -ForegroundColor Yellow
foreach ($result in $results) {
    if ($result.Status -eq "Success") {
        Write-Success "$($result.Name): Success ($([math]::Round($result.Duration, 2))s, $($result.OutputFiles) file(s))"
    }
    else {
        Write-Fail "$($result.Name): Failed - $($result.Error)"
    }
}

Write-Log "=== Master ETL Orchestrator Completed ==="
Write-Host ""
Write-Host "Full log: $logFile" -ForegroundColor Gray

# Save monthly report copy (always attempt, regardless of script results)
Write-Log ""
Write-Log "=== Saving Monthly Report ==="
Write-Host ""
Write-Host "=== Saving Monthly Report ===" -ForegroundColor Cyan
Save-MonthlyReport

if ($successCount -eq $results.Count) {
    Write-Success "All scripts completed successfully!" if (-not $SkipPowerBI) {
        Write-Host ""
        Write-Host "Next step: Run Power BI organization script" -ForegroundColor Cyan
        Write-Host "  cd `"C:\Users\carucci_r\OneDrive - City of Hackensack\PowerBI_Date`"" -ForegroundColor Gray
        Write-Host "  .\tools\organize_backfill_exports.ps1" -ForegroundColor Gray
    }
    exit 0
}
else {
    Write-Warn "Some scripts failed. Check logs for details." exit 1
}


```


Testing the function directly to ensure it works:



Creating a simple test script to verify the function works:


```powershell
# Test script for Save-MonthlyReport function
$scriptPath = "C:\Users\carucci_r\OneDrive - City of Hackensack\Master_Automation\scripts\run_all_etl.ps1"

# Source the script to load the function
. $scriptPath

# Call the function
Save-MonthlyReport

```


The function worked. Verifying the file exists and cleaning up the test file:



## Issue fixed

The function only ran when all scripts succeeded. It now runs after every execution, regardless of script results. ## What changed

1. Updated the script: `Save-MonthlyReport` now runs after every execution, not only when all scripts succeed. 2. Verified the function: tested and confirmed it creates the file correctly. ## File created

The monthly report file exists at:
```
C:\Users\carucci_r\OneDrive - City of Hackensack\Shared Folder\Compstat\Monthly Reports\2025\12_december\2025_12_Monthly_FINAL_LAP.pbix
```
- Size: 7.9 MB
- Created: Successfully copied from the template

## Next steps

When you run `scripts\run_all_etl.ps1`:
- The monthly report will be saved automatically, even if some scripts fail
- It will use `Monthly_Report_Template.pbix` from the Templates folder
- It will save to the correct directory based on the previous month (December 2025 in this case)

The function is working and will create the monthly report copy on each run. ```plaintext
C:\Users\carucci_r\OneDrive - City of Hackensack\Shared Folder\Compstat\Monthly Reports\2025\12_december\2025_12_Monthly_FINAL_LAP.pbix
```

---

**User**

@docs/m_code_for_arrest_queries.md 
___Top_5_Arrests has error Expression.Error: No arrest data found for December 2025. Check date filters and data availability. at VerifyData step
___Arrest_Categories has no preview table

---

**Cursor**


Fixing both queries: handling empty results gracefully and improving error handling. Updating the M code:



Fixing both queries to handle empty results gracefully and improve error handling:


```markdown
// ___Arrest_Categories
// ğŸ•’ 2025-09-03-17-30-00
// Project: Arrest_Analysis/Arrest_Categories
// Author: R. A. Carucci
// Purpose: Simplified M Code that relies on Python preprocessing for geographic
// data

let
    // â•â•â• A) Load latest Power BI ready file â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    FolderFiles = Folder.Files(
        "C:\Users\carucci_r\OneDrive - City of Hackensack\01_DataSources\ARREST_DATA\Power_BI"
    ),
    PowerBIFiles = Table.SelectRows(
        FolderFiles,
        each [Extension] = ".xlsx" and 
             Text.Contains([Name], "PowerBI_Ready")
    ),
    Sorted = Table.Sort(PowerBIFiles, {{"Date modified", Order.Descending}}),
    
    // Load the latest file
    Source = if Table.RowCount(Sorted) > 0 then
        Excel.Workbook(Sorted{0}[Content], null, true){0}[Data]
    else
        error "No Power BI ready files found",

    // â•â•â• B) Basic data cleaning â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Headers = Table.PromoteHeaders(Source, [PromoteAllScalars = true]),
    
    // Filter to previous month - handle multiple date column name variations
    ToDate = (x) => try Date.From(x) otherwise null,
    Prev = Date.AddMonths(Date.From(DateTime.LocalNow()), -1),
    PrevY = Date.Year(Prev),
    PrevM = Date.Month(Prev),
    
    // Find the date column (handle variations)
    DateColumnName = if Table.HasColumns(Headers, "Arrest Date") then "Arrest Date"
                     else if Table.HasColumns(Headers, "Arrest_Date") then "Arrest_Date"
                     else if Table.HasColumns(Headers, "ArrestDate") then "ArrestDate"
                     else if Table.HasColumns(Headers, "Date") then "Date"
                     else null,
    
    DateFiltered = if DateColumnName = null then
        #table({"Name", "Age", "Address", "Charge", "Arrest Date", "Home_Category_Final", "ChargeCategory", "DataQualityScore", "SourceFile"}, {})
    else
        Table.SelectRows(
            Headers,
            each let d = ToDate(Record.Field(_, DateColumnName)) in
                d <> null and Date.Year(d) = PrevY and Date.Month(d) = PrevM
        ),

    // â•â•â• C) Use Python-processed geographic data directly â•â•â•â•â•â•â•â•â•â•â•
    // Since Python already did the heavy lifting, just use the results
    WithHomeCategory = Table.AddColumn(
        DateFiltered,
        "Home_Category_Final",
        each 
            // Use Python's Home_Category if available, otherwise fallback
            if Table.HasColumns(DateFiltered, "Home_Category") then 
                [Home_Category]
            else if Text.Contains(Text.Upper([Address] ? ? ""), "HACKENSACK") then 
                "Local"
            else 
                "Check Data",
        type text
    ),

    // â•â•â• D) Simple charge categorization â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    AddChargeCategory = Table.AddColumn(
        WithHomeCategory,
        "ChargeCategory",
        each 
            let charge = Text.Upper([Charge] ? ? "") in
            if Text.Contains(charge, "ASSAULT") then "Assault"
            else if Text.Contains(charge, "SHOPLIFTING") then "Theft"
            else if Text.Contains(charge, "BURGLARY") then "Burglary"
            else if Text.Contains(charge, "ROBBERY") then "Robbery" 
            else if Text.Contains(charge, "WARRANT") then "Warrant"
            else if Text.Contains(charge, "DWI") then "DWI"
            else if Text.Contains(charge, "DRUG") then "Drug Related"
            else if Text.Contains(charge, "WEAPON") then "Weapons"
            else "Other",
        type text
    ),

    // â•â•â• E) Data quality indicators â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    AddDataQuality = Table.AddColumn(
        AddChargeCategory,
        "DataQualityScore", 
        each 
            (if [Name] <> null and [Name] <> "" then 1 else 0) +
            (if [Age] <> null and Number.From([Age] ? ? 0) > 0 then 1 else 0) +
            (if [Address] <> null and [Address] <> "" then 1 else 0) +
            (if [Charge] <> null and [Charge] <> "" then 1 else 0) +
            (if Table.HasColumns(AddChargeCategory, "ZIP") and [ZIP] <> null then 1 else 0),
        type number
    ),

    // â•â•â• F) Final type enforcement â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    TypedData = Table.TransformColumnTypes(
        AddDataQuality,
        {
            {"Age", type number},
            {"DataQualityScore", type number},
            {"Arrest Date", type date}
        }
    ),

    // â•â•â• G) Add source tracking â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    WithSourceInfo = Table.AddColumn(
        TypedData,
        "SourceFile",
        each if Table.RowCount(Sorted) > 0 then Sorted{0}[Name] else "Unknown",
        type text
    )

in
    WithSourceInfo

// ___Arrest_Distro
// ğŸ•’ 2025-08-07-14-45-00
// Project: Arrest_Analysis/Arrest_Distro
// Author: R. A. Carucci
// Purpose: Process arrest data from most recent Power BI ready file with enhanced null handling
// Fixed: Resolved all column conflict issues

let
    // 1. Load folder of Power BI ready files
    Source = Folder.Files("C:\Users\carucci_r\OneDrive - City of Hackensack\01_DataSources\ARREST_DATA\Power_BI"),
    
    // 2. Filter for UCR-updated files (CSV or Excel)
    PowerBIFiles = Table.SelectRows(Source, each
        [Attributes]?[Hidden]? <> true and
        (Text.EndsWith([Name], ".xlsx") or Text.EndsWith([Name], ".csv")) and
        (Text.Contains([Name], "ucr_updated") or Text.Contains([Name], "POWERBI_READY") or Text.Contains([Name], "PowerBI_Ready"))
    ),
    
    // 3. Sort by date modified to get the most recent file
    SortedFiles = Table.Sort(PowerBIFiles, {{"Date modified", Order.Descending}}),
    
    // 4. Diagnostic: record which file we're loading
    LatestFile = if Table.RowCount(SortedFiles) > 0 then SortedFiles{0} else error "No Power BI ready files found",
    FileName = LatestFile[Name],
    FileModifiedDate = LatestFile[Date modified],
    DiagnosticInfo = Table.AddColumn(Table.FromRecords({LatestFile}), "FileDebug", each "Processing: " & [Name] & " (Modified: " & Date.ToText([Date modified]) & ")"),
    
    // 5. Load the most recent file
    LoadedData = Table.AddColumn(DiagnosticInfo, "Data", each 
        try 
            if Text.EndsWith([Name], ".csv") then
                let
                    CsvData = Csv.Document([Content], [Delimiter=",", Columns=null, Encoding=1252, QuoteStyle=QuoteStyle.None]),
                    PromotedHeaders = Table.PromoteHeaders(CsvData, [PromoteAllScalars=true])
                in
                    PromotedHeaders
            else
                let
                    ExcelFile = Excel.Workbook([Content], null, true),
                    FirstSheet = ExcelFile{0}[Data],
                    PromotedHeaders = Table.PromoteHeaders(FirstSheet, [PromoteAllScalars=true])
                in
                    PromotedHeaders
        otherwise error "Failed to load file: " & [Name]
    ),
    
    // 6. Extract the data table
    DataTable = LoadedData{0}[Data],
    
    // 7. Remove entirely blank rows
    RemoveNulls = Table.SelectRows(DataTable, each List.NonNullCount(Record.FieldValues(_))>0),
    
    // 8. Default "Not Provided" for missing addresses (only if Address_Defaulted doesn't exist)
    WithDefaultAddress = if Table.HasColumns(RemoveNulls, "Address_Defaulted") then
        RemoveNulls
    else
        Table.AddColumn(RemoveNulls, "Address_Defaulted", each 
            if [Address] = null or [Address] = "" then "Not Provided" else try Text.From([Address]) otherwise "Not Provided"
        , type text),
    
    // 9. Handle ZIP column - use existing if available, otherwise extract from address
    WithZIP = if Table.HasColumns(WithDefaultAddress, "ZIP") then
        // ZIP column already exists, just ensure it's text type
        Table.TransformColumns(WithDefaultAddress, {{"ZIP", each try Text.From(_) otherwise "", type text}})
    else if Table.HasColumns(WithDefaultAddress, "ExtractedZIP") then
        // Use ExtractedZIP and rename it to ZIP
        Table.RenameColumns(WithDefaultAddress, {{"ExtractedZIP", "ZIP"}})
    else
        // Extract ZIP from address
        Table.AddColumn(WithDefaultAddress, "ZIP", each
            let
                addr = [Address_Defaulted],
                tokens = if addr = "Not Provided" then {} else Text.Split(addr, " "),
                candidates = List.Select(tokens, each 
                    let s = Text.Select(_, {"0".."9"})
                    in Text.Length(if Text.Contains(_, "-") then Text.BeforeDelimiter(_, "-") else s)=5
                )
            in
                if List.Count(candidates)>0 
                then Text.Select(if Text.Contains(candidates{0},"-") then Text.BeforeDelimiter(candidates{0},"-") else candidates{0}, {"0".."9"})
                else null
            , type text),
    
    // 10. Flag valid 5-digit ZIPs (only if ValidZIP doesn't exist)
    WithValidZipFlag = if Table.HasColumns(WithZIP, "ValidZIP") then
        WithZIP
    else
        Table.AddColumn(WithZIP, "ValidZIP", each
            let z = try Text.From([ZIP]) otherwise ""
            in Text.Length(z)=5 and Text.Length(Text.Select(z,{"0".."9"}))=5
        , type logical),
    
    // 11. Ensure Arrest Date is a nullable date
    ConvertedDates = if Table.HasColumns(WithValidZipFlag, "Arrest Date") then
        Table.TransformColumns(WithValidZipFlag, {{"Arrest Date", each try Date.From(_) otherwise null, type nullable date}})
    else
        WithValidZipFlag,
    
    // 12. Add final record index (only if it doesn't already exist)
    AddFinalIndex = if Table.HasColumns(ConvertedDates, "RecordIndex") then
        ConvertedDates
    else
        Table.AddIndexColumn(ConvertedDates, "RecordIndex", 1, 1, Int64.Type),
    
    // 13. Load ZIP reference data
    ZIPRef = try Csv.Document(File.Contents("C:\Users\carucci_r\OneDrive - City of Hackensack\09_Reference\GeographicData\ZipCodes\uszips.csv"), [Delimiter=",", Encoding=1252, QuoteStyle=QuoteStyle.None]) otherwise #table({"zip","state_id","county_name"},{}),
    ZIPHeaders = Table.PromoteHeaders(ZIPRef, [PromoteAllScalars=true]),
    ZIPNullHandled = Table.ReplaceValue(ZIPHeaders, null, "", Replacer.ReplaceValue, {"zip","state_id","county_name"}),
    ZIPCleaned = Table.TransformColumnTypes(Table.SelectColumns(ZIPNullHandled,{"zip","state_id","county_name"}), {{"zip", type text}}),
    
    // 14.